id: ci.license_compliance_v1
version: 1.0.0
domain: ci
title: License Compliance â€” Allowlist Only
statement: All package licenses in the SBOM must be on an allowlist. Fail on any package
  with a disallowed or unknown license.
witnesses:
- name: spdx_allowlist_only
  language: python
  entrypoint: python3
  args: []
  env:
    SBOM_PATH: artifacts/examples/ci/sbom.json
    ALLOWED_LICENSES_JSON: '["MIT","Apache-2.0","BSD-3-Clause","BSD-2-Clause","ISC","Python-2.0"]'
    STRICT_FIELDS_ONLY: 'true'
    IGNORE_NUMERIC_TOKENS: 'true'
  timeout_ms: 5000
  memory_mb: 128
  net: false
  fs_mode: ro
  code: "import os, json, sys, re\n\nVERSION_RE = re.compile(r\"^\\d+(?:\\.\\d+){0,3}$\"\
    )\n\ndef env_bool(name, default):\n    v = os.environ.get(name, str(default)).strip().lower()\n\
    \    return v in (\"1\",\"true\",\"yes\",\"on\")\n\ndef load_json(path):\n   \
    \ with open(path, \"r\", errors=\"ignore\") as f:\n        return json.load(f)\n\
    \ndef norm(s):\n    return (s or \"\").strip()\n\ndef collect_from_known_fields(sbom):\n\
    \    out = set()\n\n    # CycloneDX components\n    comps = sbom.get(\"components\"\
    ) or []\n    for c in comps:\n        # CycloneDX license list format\n      \
    \  lic_list = c.get(\"licenses\") or []\n        for it in lic_list:\n       \
    \     if isinstance(it, dict):\n                lic = it.get(\"license\")\n  \
    \              if isinstance(lic, dict):\n                    out.add(norm(lic.get(\"\
    id\") or lic.get(\"name\")))\n                elif isinstance(lic, str):\n   \
    \                 out.add(norm(lic))\n        # simple fallback: component.license\n\
    \        if isinstance(c.get(\"license\"), str):\n            out.add(norm(c[\"\
    license\"]))\n        elif isinstance(c.get(\"license\"), dict):\n           \
    \ out.add(norm(c[\"license\"].get(\"id\") or c[\"license\"].get(\"name\")))\n\n\
    \    # SPDX packages\n    pkgs = sbom.get(\"packages\") or []\n    for p in pkgs:\n\
    \        for key in (\"licenseConcluded\",\"licenseDeclared\",\"license\"):\n\
    \            if key in p and p[key]:\n                if isinstance(p[key], str):\n\
    \                    out.add(norm(p[key]))\n                elif isinstance(p[key],\
    \ dict):\n                    out.add(norm(p[key].get(\"id\") or p[key].get(\"\
    name\")))\n\n    return {x for x in out if x}\n\ndef collect_heuristic_tokens(sbom):\n\
    \    # Last-resort heuristic over raw text; may misfire.\n    # We will filter\
    \ numeric/version-looking tokens below.\n    text = json.dumps(sbom, ensure_ascii=False)\n\
    \    # Simple token pass for SPDX-like ids\n    toks = set(re.findall(r\"\\b[A-Za-z][A-Za-z0-9\\\
    .\\-\\+]{1,}\\b\", text))\n    return toks\n\ndef main():\n    sbom_path = os.environ.get(\"\
    SBOM_PATH\", \"artifacts/examples/ci/sbom.json\")\n    try:\n        allow = set(json.loads(os.environ.get(\n\
    \            \"ALLOWED_LICENSES_JSON\",\n            '[\"MIT\",\"Apache-2.0\"\
    ,\"BSD-3-Clause\",\"BSD-2-Clause\",\"ISC\",\"Python-2.0\"]'\n        )))\n   \
    \ except Exception:\n        allow = {\"MIT\",\"Apache-2.0\",\"BSD-3-Clause\"\
    ,\"BSD-2-Clause\",\"ISC\",\"Python-2.0\"}\n\n    STRICT = env_bool(\"STRICT_FIELDS_ONLY\"\
    , True)\n    IGN_NUM = env_bool(\"IGNORE_NUMERIC_TOKENS\", True)\n\n    try:\n\
    \        sbom = load_json(sbom_path)\n    except Exception as e:\n        print(json.dumps({\"\
    ok\": False, \"error\": f\"load:{e}\", \"sbom_path\": sbom_path}, indent=2))\n\
    \        sys.exit(1)\n\n    licenses = set()\n    # Prefer structured fields\n\
    \    licenses |= collect_from_known_fields(sbom)\n\n    if not STRICT:\n     \
    \   # Heuristic fallback (filtered)\n        licenses |= collect_heuristic_tokens(sbom)\n\
    \n    # Filter empties and numeric/version-looking tokens\n    cleaned = []\n\
    \    for x in licenses:\n        if not x: \n            continue\n        if\
    \ IGN_NUM and VERSION_RE.match(x):\n            continue\n        cleaned.append(x)\n\
    \n    cleaned = sorted(set(map(str, cleaned)))\n    disallowed = sorted({x for\
    \ x in cleaned if x not in allow})\n\n    result = {\n        \"ok\": len(disallowed)\
    \ == 0,\n        \"licenses\": cleaned,\n        \"disallowed\": disallowed,\n\
    \        \"allowlist\": sorted(allow),\n        \"strict_fields_only\": STRICT,\n\
    \        \"ignore_numeric_tokens\": IGN_NUM\n    }\n    print(json.dumps(result,\
    \ indent=2))\n    sys.exit(0 if result[\"ok\"] else 1)\n\nif __name__ == \"__main__\"\
    :\n    main()"
provenance:
  schema: provenance.v1
  author: John Macgregor
  org: Truth Capsules Demo
  license: MIT
  source_url: https://example.com/truth-capsules/ci
  created: '2025-11-10T21:10:00Z'
  updated: '2025-11-10T21:10:00Z'
  review:
    status: draft
    reviewers: []
    last_reviewed: null
  signing:
    method: ed25519
    key_id: null
    pubkey: null
    digest: 50c30132e006962dc3b94bf31df05f48ff44f54f5e4512232e148ab0d55dbc24
    signature: null
applies_to:
- ci
- release
security:
  sensitivity: medium
  notes: Runs in restricted CI; no network by default; read-only FS recommended.
